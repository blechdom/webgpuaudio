self.addEventListener("message",(async e=>{if("run"===e.data.type)try{await async function(e,a,t,r,s,n){void 0===t&&(t=64),void 0===r&&(r=48e3),void 0===s&&(s=0),void 0===n&&(n="synthesize");const o=r*e,u=2*o,i=u*Float32Array.BYTES_PER_ELEMENT,f=await navigator.gpu.requestAdapter();let c=await f.requestDevice(),d=c.createBuffer({size:Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),g=c.createBuffer({size:i,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),p=c.createBuffer({size:i,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),l=c.createShaderModule({code:a});const P=c.createComputePipeline({layout:"auto",compute:{module:l,entryPoint:n,constants:{SAMPLE_RATE:r,WORKGROUP_SIZE:t}}}),y=c.createBindGroup({layout:P.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:d}},{binding:1,resource:{buffer:g}}]});async function E(){c.queue.writeBuffer(d,0,new Float32Array([s]));const e=c.createCommandEncoder(),a=e.beginComputePass();a.setPipeline(P),a.setBindGroup(0,y),a.dispatchWorkgroups(Math.ceil(o/t)),a.end(),e.copyBufferToBuffer(g,0,p,0,i),c.queue.submit([e.finish()]),await p.mapAsync(GPUMapMode.READ,0,i);const r=new Float32Array(u);r.set(new Float32Array(p.getMappedRange())),p.unmap(),self.postMessage({type:"chunk",chunkData:r})}await E()}(e.data.chunkDurationInSeconds,e.data.code,e.data.workgroupSize,e.data.sampleRate,e.data.nextChunkOffset)}catch(a){self.postMessage({type:"log",message:`Error while initializing WebGPU in worker process: ${a.message}`})}}));