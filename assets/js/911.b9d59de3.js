(()=>{"use strict";__webpack_require__.gca=function(t){return t={}[t]||t,__webpack_require__.p+__webpack_require__.u(t)};class t{States={READ:0,WRITE:1};constructor(t,e){void 0===e&&(e=1),this.states=new Uint32Array(new SharedArrayBuffer(Object.keys(this.States).length*Uint32Array.BYTES_PER_ELEMENT)),this.bufferLength=t+1,this.channelCount=e,this.channelData=[];for(let a=0;a<e;a++)this.channelData.push(new Float32Array(new SharedArrayBuffer(this.bufferLength*Float32Array.BYTES_PER_ELEMENT)))}static fromPointers(e){const a=new t(0,0),s=new Uint32Array(e.memory.buffer),r=new Float32Array(e.memory.buffer),i=s[e.bufferLengthPointer/4],n=s[e.channelCountPointer/4],o=s.subarray(s[e.statePointer/4]/4,s[e.statePointer/4]/4+2),u=[];for(let t=0;t<n;t++)u.push(r.subarray(s[s[e.channelDataPointer/4]/4+t]/4,s[s[e.channelDataPointer/4]/4+t]/4+i));return a.bufferLength=i,a.channelCount=n,a.states=o,a.channelData=u,a}push(t,e){const a=Atomics.load(this.states,this.States.READ),s=Atomics.load(this.states,this.States.WRITE);if(this._getAvailableWrite(a,s)<e)return!1;let r=s+e;if(this.bufferLength<r){r-=this.bufferLength;for(let e=0;e<this.channelCount;e++){const a=this.channelData[e].subarray(s),i=this.channelData[e].subarray(0,r);a.set(t[e].subarray(0,a.length)),i.set(t[e].subarray(a.length))}}else{for(let a=0;a<this.channelCount;a++)this.channelData[a].subarray(s,r).set(t[a].subarray(0,e));r===this.bufferLength&&(r=0)}return Atomics.store(this.states,this.States.WRITE,r),!0}pull(t,e){const a=Atomics.load(this.states,this.States.READ),s=Atomics.load(this.states,this.States.WRITE);if(this._getAvailableRead(a,s)<e)return!1;let r=a+e;if(this.bufferLength<r){r-=this.bufferLength;for(let e=0;e<this.channelCount;e++){const s=this.channelData[e].subarray(a),i=this.channelData[e].subarray(0,r);t[e].set(s),t[e].set(i,s.length)}}else{for(let e=0;e<this.channelCount;++e)t[e].set(this.channelData[e].subarray(a,r));r===this.bufferLength&&(r=0)}return Atomics.store(this.states,this.States.READ,r),!0}printAvailableReadAndWrite(){const t=Atomics.load(this.states,this.States.READ),e=Atomics.load(this.states,this.States.WRITE);console.log(this,{availableRead:this._getAvailableRead(t,e),availableWrite:this._getAvailableWrite(t,e)})}getAvailableSamples(){const t=Atomics.load(this.states,this.States.READ),e=Atomics.load(this.states,this.States.WRITE);return this._getAvailableRead(t,e)}isFrameAvailable(t){return this.getAvailableSamples()>=t}getBufferLength(){return this.bufferLength-1}_getAvailableWrite(t,e){return e>=t?this.bufferLength-e+t-1:t-e-1}_getAvailableRead(t,e){return e>=t?e-t:e+this.bufferLength-t}_reset(){for(let t=0;t<this.channelCount;t++)this.channelData[t].fill(0);Atomics.store(this.states,this.States.READ,0),Atomics.store(this.states,this.States.WRITE,0)}}const e=t,a=2560;self.addEventListener("message",(async t=>{switch(t.data.type){case"init":{let{inputQueue:s,outputQueue:r,atomicState:i}=t.data.data;Object.setPrototypeOf(s,e.prototype),Object.setPrototypeOf(r,e.prototype);const n=new Float32Array(a);for(;"ok"===Atomics.wait(i,0,0);){if(s.pull([n],a)){console.log("pushing");const t=n.map((t=>.1*t));r.push([t],a)}Atomics.store(i,0,0)}}case"run":try{await async function(t,e,a,s,r,i){void 0===a&&(a=64);void 0===s&&(s=48e3);void 0===r&&(r=0);void 0===i&&(i="synthesize");const n=s*t,o=NUM_CHANNELS*n,u=o*Float32Array.BYTES_PER_ELEMENT,h=await navigator.gpu.requestAdapter();let l=await h.requestDevice(),c=l.createBuffer({size:Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),f=l.createBuffer({size:u,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),g=l.createBuffer({size:u,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),A=l.createShaderModule({code:e});const b=l.createComputePipeline({layout:"auto",compute:{module:A,entryPoint:i,constants:{SAMPLE_RATE:s,WORKGROUP_SIZE:a}}}),d=l.createBindGroup({layout:b.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:c}},{binding:1,resource:{buffer:f}}]});async function p(){l.queue.writeBuffer(c,0,new Float32Array([r]));const t=l.createCommandEncoder(),e=t.beginComputePass();e.setPipeline(b),e.setBindGroup(0,d),e.dispatchWorkgroups(Math.ceil(n/a)),e.end(),t.copyBufferToBuffer(f,0,g,0,u),l.queue.submit([t.finish()]),await g.mapAsync(GPUMapMode.READ,0,u);const s=new Float32Array(o);s.set(new Float32Array(g.getMappedRange())),g.unmap(),self.postMessage({type:"chunk",chunkData:s})}await p()}(t.data.chunkDurationInSeconds,t.data.code,t.data.workgroupSize,t.data.sampleRate,t.data.nextChunkOffset)}catch(s){self.postMessage({type:"log",message:`Error while initializing WebGPU in worker process: ${s.message}`})}}}))})();