"use strict";(self.webpackChunkwebgpuaudio=self.webpackChunkwebgpuaudio||[]).push([[918],{3684:(e,t,i)=>{i.d(t,{Z:()=>n});var s=i(7294),a=i(8281);var u=i(3947);const n={React:s,...s,Leva:a.Zf,useControls:a.M4,button:a.LI,WebAudioOscillator:class{constructor(){this.audioContext=new AudioContext,this.oscillator=this.audioContext.createOscillator(),this.gain=this.audioContext.createGain(),this.oscillator.connect(this.gain),this.gain.gain.value=0,this.gain.connect(this.audioContext.destination),this.oscillator.start()}setVolume(e){this.gain.gain.setTargetAtTime(e,this.audioContext.currentTime,.01)}setFrequency(e){this.oscillator.frequency.setTargetAtTime(e,this.audioContext.currentTime,.01)}setWaveForm(e){this.oscillator.type=e}stop(){this.gain.gain.setTargetAtTime(0,this.audioContext.currentTime,.01),setTimeout((()=>{this.oscillator.stop(),this.oscillator.disconnect(),this.gain.disconnect(),this.audioContext&&this.audioContext.close(),this.audioContext&&(this.audioContext=void 0)}),100)}},WebGpuAudioEngine:u.Z}},3947:(e,t,i)=>{i.d(t,{Z:()=>s});class s{timeoutId=null;nextChunkOffset=0;workgroupSize=0;constructor(e){this.audioContext=new AudioContext,this.sampleRate=this.audioContext.sampleRate,this.chunkDurationInSeconds=e,this.chunkNumSamplesPerChannel=this.sampleRate*e,this.chunkNumSamples=2*this.chunkNumSamplesPerChannel,this.chunkBufferSize=this.chunkNumSamples*Float32Array.BYTES_PER_ELEMENT}async initGPU(e){let{code:t,entryPoint:i,workgroupSize:s}=e;this.workgroupSize=s;const a=await navigator.gpu.requestAdapter();this.device=await a.requestDevice(),this.timeInfoBuffer=this.device.createBuffer({size:Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.chunkBuffer=this.device.createBuffer({size:this.chunkBufferSize,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),this.chunkMapBuffer=this.device.createBuffer({size:this.chunkBufferSize,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),this.audioParamBuffer=this.device.createBuffer({size:3*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),this.audioShaderModule=this.device.createShaderModule({code:t}),this.pipeline=this.device.createComputePipeline({layout:"auto",compute:{module:this.audioShaderModule,entryPoint:i,constants:{SAMPLE_RATE:this.sampleRate,WORKGROUP_SIZE:s}}}),this.bindGroup=this.device.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this.timeInfoBuffer}},{binding:1,resource:{buffer:this.chunkBuffer}},{binding:2,resource:{buffer:this.audioParamBuffer}}]})}playSound(){(async()=>{await this.createSoundChunk()})()}async createSoundChunk(){if(!this.audioContext)return;void 0===this.startTime&&(this.startTime=performance.now()/1e3),console.log("this.nextChunkOffset",this.nextChunkOffset);const e=this.startTime+this.nextChunkOffset-performance.now()/1e3;if(Math.floor(e/this.chunkDurationInSeconds)>2){const e=this.chunkDurationInSeconds;return void(this.timeoutId=setTimeout(await this.createSoundChunk.bind(this),1e3*e))}this.device.queue.writeBuffer(this.timeInfoBuffer,0,new Float32Array([this.nextChunkOffset]));const t=this.device.createCommandEncoder(),i=t.beginComputePass();i.setPipeline(this.pipeline),i.setBindGroup(0,this.bindGroup),i.dispatchWorkgroups(Math.ceil(this.chunkNumSamplesPerChannel/this.workgroupSize)),i.end(),t.copyBufferToBuffer(this.chunkBuffer,0,this.chunkMapBuffer,0,this.chunkBufferSize),this.device.queue.submit([t.finish()]),await this.chunkMapBuffer.mapAsync(GPUMapMode.READ,0,this.chunkBufferSize);const s=new Float32Array(this.chunkNumSamples);s.set(new Float32Array(this.chunkMapBuffer.getMappedRange())),this.chunkMapBuffer.unmap();const a=this.audioContext.createBuffer(2,this.chunkNumSamplesPerChannel,this.audioContext.sampleRate),u=[];for(let o=0;o<2;++o)u.push(a.getChannelData(o));for(let o=0;o<a.length;++o)for(const[e,t]of u.entries())t[o]=s[2*o+e];const n=this.audioContext.createBufferSource();n.buffer=a,n.connect(this.audioContext.destination),0!==this.nextChunkOffset&&n.start(this.nextChunkOffset),this.nextChunkOffset+=n.buffer.duration,await this.createSoundChunk()}updateAudioParams(e,t,i){this.device.queue.writeBuffer(this.audioParamBuffer,0,new Float32Array([e,t,i]))}async stop(){this.timeoutId&&clearTimeout(this.timeoutId),this.audioContext&&await this.audioContext.suspend(),this.audioContext&&await this.audioContext.close()}}}}]);