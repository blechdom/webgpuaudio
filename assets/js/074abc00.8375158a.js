"use strict";(self.webpackChunkwebgpuaudio=self.webpackChunkwebgpuaudio||[]).push([[842],{1301:(n,e,a)=>{a.r(e),a.d(e,{default:()=>s});var r=a(7294),o=a(2308),i=a(1077),u=a(6386),t=a(5893);const f="override WORKGROUP_SIZE: u32 = 256;\noverride SAMPLE_RATE: f32 = 48000.0;\nconst PI2: f32 = 6.283185307179586476925286766559;\n\nstruct TimeInfo {\n    offset: f32,\n}\n\nstruct AudioParam {\n  frequency: f32,\n  gain: f32,\n  waveForm: f32\n}\n\nvar<private> last_frequency: f32 = 200;\n\n@binding(0) @group(0) var<uniform> time_info: TimeInfo;\n@binding(1) @group(0) var<storage, read_write> sound_chunk: array<vec2<f32>>;\n@binding(2) @group(0) var<storage, read> audio_param: AudioParam;\n\n@compute\n@workgroup_size(WORKGROUP_SIZE)\nfn synthesize(@builtin(global_invocation_id) global_id: vec3<u32>) {\n    var sampleCount: u32 = global_id.x; // 0 -> keeps on counting and counting and counting\n\n    if (sampleCount >= arrayLength(&sound_chunk)) {\n        return;\n    }\n\n    var t = f32(sampleCount) / SAMPLE_RATE;\n    \n    var chunkPosition = f32(sampleCount % (arrayLength(&sound_chunk)/2))/SAMPLE_RATE; \n    \n    var next_frequency = audio_param.frequency * chunkPosition;\n \n    sound_chunk[sampleCount] = oscillator(time_info.offset + t, next_frequency, audio_param.gain, audio_param.waveForm);\n}\n\nfn oscillator(time: f32, frequency: f32, gain: f32, waveForm: f32) -> vec2<f32> {\n\n    \n    var v: f32 = sin(time * frequency * PI2);\n   /* if (waveForm == 1) {\n       v = -abs(fract(time * frequency)-.5)*4.0-1.0;\n    } else if (waveForm == 2) {\n        v = step(fract(time * frequency),0.5)*2.0-1.0;\n    } else if (waveForm == 3) {\n        v = 1.0 - 2.0*fract(time * frequency);\n    }*/\n    return vec2(v * gain);\n}\n";function s(){const[n,e]=r.useState(f),a=r.useCallback(((n,a)=>{console.log("val:",n),e(n)}),[]);return(0,t.jsx)(u.Z,{children:(0,t.jsx)(o.ZP,{value:n,width:"90%",height:"400px",extensions:[(0,i.i)()],onChange:a})})}}}]);