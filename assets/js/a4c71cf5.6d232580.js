"use strict";(self.webpackChunkwebgpuaudio=self.webpackChunkwebgpuaudio||[]).push([[876],{2281:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>_,contentTitle:()=>g,default:()=>E,frontMatter:()=>m,metadata:()=>v,toc:()=>k});var i=t(5893),o=t(7294),s=t(1229),r=t(1077),a=t(8281),u=t(6224),f=t(2584),c=t(6998),d=t(6944),l=t(9639),h=t(9947),p=t(5095);const m={title:"WGSL Audio Editor, no real-time inputs",sidebar_position:1},g=void 0,v={id:"webWorker/WgslAudioNoInput",title:"WGSL Audio Editor, no real-time inputs",description:"const [playing, setPlaying] = useState(false);",source:"@site/docs/webWorker/WgslAudioNoInput.mdx",sourceDirName:"webWorker",slug:"/webWorker/WgslAudioNoInput",permalink:"/docs/webWorker/WgslAudioNoInput",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"WGSL Audio Editor, no real-time inputs",sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Web Workers and ring buffers",permalink:"/docs/category/web-workers-and-ring-buffers"},next:{title:"WebAudio Oscillators",permalink:"/docs/webAudioOscillators"}},_={},k=[],S=function(){const e=[1,2,4,8,16,32,64,128,256],[n,t]=(0,o.useState)(!1),[m,g]=(0,o.useState)(void 0),[v,_]=o.useState(f.Z);(0,o.useEffect)((()=>()=>{P()}),[]);const k=(0,o.useCallback)(((e,n)=>{console.log("val:",e),_(e)}),[]),{chunkDurationInSeconds:S,workgroupSize:b,loadShader:E}=(0,a.M4)({loadShader:{options:["sine","triangle","square","sawtooth","globalIdX","time"]},chunkDurationInSeconds:{value:.25,min:.03,max:1,step:.01},workgroupSize:{options:e,value:e[8]},[n?"Stop Sound":"Play Sound"]:(0,a.LI)((()=>{t(!n)}))},[n]);async function P(){m&&(await m.stop(),g(void 0))}return(0,o.useEffect)((()=>{n?async function(){if(void 0===m){const e=new u.Z(S);await e.initGPU({code:v,entryPoint:"synthesize",workgroupSize:b}),g(e)}}():P()}),[n]),(0,o.useEffect)((()=>{n&&t(!1)}),[S,b,v]),(0,o.useEffect)((()=>{switch(console.log("shader",E),E){case"sine":default:_(f.Z);break;case"triangle":_(c.Z);break;case"square":_(d.Z);break;case"sawtooth":_(l.Z);break;case"globalIdX":_(h.Z);break;case"time":_(p.Z)}}),[E]),(0,o.useEffect)((()=>{m&&m.playSound()}),[m]),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(a.Zf,{flat:!0,oneLineLabels:!0}),(0,i.jsx)(s.ZP,{value:v,width:"90%",height:"400px",extensions:[(0,r.i)()],onChange:k})]})};function b(e){return(0,i.jsx)(i.Fragment,{})}function E(e={}){return(0,i.jsx)(S,{...e,children:(0,i.jsx)(b,{...e})})}},6224:(e,n,t)=>{t.d(n,{Z:()=>i});class i{timeoutId=null;nextChunkOffset=0;workgroupSize=0;constructor(e){this.audioContext=new AudioContext,this.sampleRate=this.audioContext.sampleRate,this.chunkDurationInSeconds=e,this.chunkNumSamplesPerChannel=this.sampleRate*e,this.chunkNumSamples=2*this.chunkNumSamplesPerChannel,this.chunkBufferSize=this.chunkNumSamples*Float32Array.BYTES_PER_ELEMENT}async initGPU(e){let{code:n,entryPoint:t,workgroupSize:i}=e;this.workgroupSize=i;const o=await navigator.gpu.requestAdapter();this.device=await o.requestDevice(),this.timeInfoBuffer=this.device.createBuffer({size:Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.chunkBuffer=this.device.createBuffer({size:this.chunkBufferSize,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),this.chunkMapBuffer=this.device.createBuffer({size:this.chunkBufferSize,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),this.audioShaderModule=this.device.createShaderModule({code:n}),this.pipeline=this.device.createComputePipeline({layout:"auto",compute:{module:this.audioShaderModule,entryPoint:t,constants:{SAMPLE_RATE:this.sampleRate,WORKGROUP_SIZE:i}}}),this.bindGroup=this.device.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this.timeInfoBuffer}},{binding:1,resource:{buffer:this.chunkBuffer}}]})}playSound(){(async()=>{await this.createSoundChunk()})()}async createSoundChunk(){if(!this.audioContext)return;void 0===this.startTime&&(this.startTime=performance.now()/1e3);const e=this.startTime+this.nextChunkOffset-performance.now()/1e3;if(Math.floor(e/this.chunkDurationInSeconds)>2){const e=this.chunkDurationInSeconds;return void(this.timeoutId=setTimeout(await this.createSoundChunk.bind(this),1e3*e))}this.device.queue.writeBuffer(this.timeInfoBuffer,0,new Float32Array([this.nextChunkOffset]));const n=this.device.createCommandEncoder(),t=n.beginComputePass();t.setPipeline(this.pipeline),t.setBindGroup(0,this.bindGroup),t.dispatchWorkgroups(Math.ceil(this.chunkNumSamplesPerChannel/this.workgroupSize)),t.end(),n.copyBufferToBuffer(this.chunkBuffer,0,this.chunkMapBuffer,0,this.chunkBufferSize),this.device.queue.submit([n.finish()]),await this.chunkMapBuffer.mapAsync(GPUMapMode.READ,0,this.chunkBufferSize);const i=new Float32Array(this.chunkNumSamples);i.set(new Float32Array(this.chunkMapBuffer.getMappedRange())),this.chunkMapBuffer.unmap();const o=this.audioContext.createBuffer(2,this.chunkNumSamplesPerChannel,this.audioContext.sampleRate),s=[];for(let a=0;a<2;++a)s.push(o.getChannelData(a));for(let a=0;a<o.length;++a)for(const[e,n]of s.entries())n[a]=i[2*a+e];const r=this.audioContext.createBufferSource();r.buffer=o,r.connect(this.audioContext.destination),0!==this.nextChunkOffset&&r.start(this.nextChunkOffset),this.nextChunkOffset+=r.buffer.duration,await this.createSoundChunk()}async stop(){this.timeoutId&&clearTimeout(this.timeoutId),this.audioContext&&await this.audioContext.suspend(),this.audioContext&&await this.audioContext.close()}}},9947:(e,n,t)=>{t.d(n,{Z:()=>i});const i="override WORKGROUP_SIZE: u32 = 256;\noverride SAMPLE_RATE: f32 = 44100.0;\nconst PI2: f32 = 6.283185307179586476925286766559;\n\nstruct TimeInfo { offset: f32 }\n\n@group(0) @binding(0) var<uniform> time_info: TimeInfo;\n@group(0) @binding(1) var<storage, read_write> sound_chunk: array<vec2<f32>>;\n\n@compute @workgroup_size(WORKGROUP_SIZE)\nfn synthesize(@builtin(global_invocation_id) global_id: vec3<u32>) {\n    let sampleX = global_id.x;\n\n    let t = f32(sampleX) / SAMPLE_RATE;\n\n    sound_chunk[sampleX] = sine(time_info.offset + t, f32(global_id.x));\n}\n\nfn sine(time: f32, freq: f32) -> vec2<f32> {\n    var v: f32 = sin(time * freq * PI2);\n    const amp: f32 = 0.25;\n    return vec2(v * amp);\n}"},9639:(e,n,t)=>{t.d(n,{Z:()=>i});const i="override WORKGROUP_SIZE: u32 = 256;\noverride SAMPLE_RATE: f32 = 44100.0;\n\nstruct TimeInfo { offset: f32 }\n\n@group(0) @binding(0) var<uniform> time_info: TimeInfo;\n@group(0) @binding(1) var<storage, read_write> sound_chunk: array<vec2<f32>>;\n\n@compute\n@workgroup_size(WORKGROUP_SIZE)\nfn synthesize(@builtin(global_invocation_id) global_id: vec3<u32>) {\n    let sampleX = global_id.x;\n\n    let t = f32(sampleX) / SAMPLE_RATE;\n\n    sound_chunk[sampleX] = sine(time_info.offset + t);\n}\n\nfn sine(time: f32) -> vec2<f32> {\n    const freq: f32 = 333;\n    var v: f32 = 1.0 - 2.0*fract(time * freq);\n    const amp: f32 = 0.25;\n    return vec2(v * amp);\n}"},2584:(e,n,t)=>{t.d(n,{Z:()=>i});const i="override WORKGROUP_SIZE: u32 = 256;\noverride SAMPLE_RATE: f32 = 44100.0;\nconst PI2: f32 = 6.283185307179586476925286766559;\n\nstruct TimeInfo { offset: f32 }\n\n@group(0) @binding(0) var<uniform> time_info: TimeInfo;\n@group(0) @binding(1) var<storage, read_write> sound_chunk: array<vec2<f32>>;\n\n@compute @workgroup_size(WORKGROUP_SIZE)\nfn synthesize(@builtin(global_invocation_id) global_id: vec3<u32>) {\n    let sampleX = global_id.x;\n\n    let t = f32(sampleX) / SAMPLE_RATE;\n\n    sound_chunk[sampleX] = sine(time_info.offset + t);\n}\n\nfn sine(time: f32) -> vec2<f32> {\n    const freq: f32 = 333;\n    var v: f32 = sin(time * freq * PI2);\n    const amp: f32 = 0.25;\n    return vec2(v * amp);\n}"},6944:(e,n,t)=>{t.d(n,{Z:()=>i});const i="override WORKGROUP_SIZE: u32 = 256;\noverride SAMPLE_RATE: f32 = 44100.0;\n\nstruct TimeInfo { offset: f32 }\n\n@group(0) @binding(0) var<uniform> time_info: TimeInfo;\n@group(0) @binding(1) var<storage, read_write> sound_chunk: array<vec2<f32>>;\n\n@compute @workgroup_size(WORKGROUP_SIZE)\nfn synthesize(@builtin(global_invocation_id) global_id: vec3<u32>) {\n    let sampleX = global_id.x;\n\n    let t = f32(sampleX) / SAMPLE_RATE;\n\n    sound_chunk[sampleX] = square(time_info.offset + t);\n}\n\nfn square(time: f32) -> vec2<f32> {\n    const freq: f32 = 333;\n    var v: f32 = step(fract(time * freq), 0.5) * 2.0 - 1.0;\n    const amp: f32 = 0.25;\n    return vec2(v * amp);\n}"},5095:(e,n,t)=>{t.d(n,{Z:()=>i});const i="override WORKGROUP_SIZE: u32 = 256;\noverride SAMPLE_RATE: f32 = 44100.0;\nconst PI2: f32 = 6.283185307179586476925286766559;\n\nstruct TimeInfo { offset: f32 }\n\n@group(0) @binding(0) var<uniform> time_info: TimeInfo;\n@group(0) @binding(1) var<storage, read_write> sound_chunk: array<vec2<f32>>;\n\n@compute @workgroup_size(WORKGROUP_SIZE)\nfn synthesize(@builtin(global_invocation_id) global_id: vec3<u32>) {\n    let sampleX = global_id.x;\n\n    let t = f32(sampleX) / SAMPLE_RATE;\n\n    sound_chunk[sampleX] = sine(time_info.offset + t, ((t - time_info.offset) * 400) + 200);\n}\n\nfn sine(time: f32, freq: f32) -> vec2<f32> {\n    var v: f32 = sin(time * freq * PI2);\n    const amp: f32 = 0.25;\n    return vec2(v * amp);\n}"},6998:(e,n,t)=>{t.d(n,{Z:()=>i});const i="override WORKGROUP_SIZE: u32 = 256;\noverride SAMPLE_RATE: f32 = 44100.0;\n\nstruct TimeInfo { offset: f32 }\n\n@group(0) @binding(0) var<uniform> time_info: TimeInfo;\n@group(0) @binding(1) var<storage, read_write> sound_chunk: array<vec2<f32>>;\n\n@compute @workgroup_size(WORKGROUP_SIZE)\nfn synthesize(@builtin(global_invocation_id) global_id: vec3<u32>) {\n    let sampleX = global_id.x;\n\n    let t = f32(sampleX) / SAMPLE_RATE;\n\n    sound_chunk[sampleX] = triangleWave(time_info.offset + t);\n}\n\nfn triangleWave(time: f32) -> vec2<f32> {\n    const freq: f32 = 333;\n    var v: f32 = -abs(fract(time * freq)-0.5)*4.0-1.0;\n    const amp: f32 = 0.25;\n    return vec2(v * amp);\n}"}}]);