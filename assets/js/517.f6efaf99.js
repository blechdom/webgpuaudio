(()=>{"use strict";__webpack_require__.gca=function(t){return t={}[t]||t,__webpack_require__.p+__webpack_require__.u(t)};class t{States={READ:0,WRITE:1};constructor(t,e){void 0===e&&(e=1),this.states=new Uint32Array(new SharedArrayBuffer(Object.keys(this.States).length*Uint32Array.BYTES_PER_ELEMENT)),this.bufferLength=t+1,this.channelCount=e,this.channelData=[];for(let a=0;a<e;a++)this.channelData.push(new Float32Array(new SharedArrayBuffer(this.bufferLength*Float32Array.BYTES_PER_ELEMENT)))}static fromPointers(e){const a=new t(0,0),s=new Uint32Array(e.memory.buffer),r=new Float32Array(e.memory.buffer),n=s[e.bufferLengthPointer/4],i=s[e.channelCountPointer/4],o=s.subarray(s[e.statePointer/4]/4,s[e.statePointer/4]/4+2),u=[];for(let t=0;t<i;t++)u.push(r.subarray(s[s[e.channelDataPointer/4]/4+t]/4,s[s[e.channelDataPointer/4]/4+t]/4+n));return a.bufferLength=n,a.channelCount=i,a.states=o,a.channelData=u,a}push(t,e){Atomics.load(this.states,this.States.READ);const a=Atomics.load(this.states,this.States.WRITE);let s=a+e;if(this.bufferLength<s){s-=this.bufferLength;for(let e=0;e<this.channelCount;e++){const r=this.channelData[e].subarray(a),n=this.channelData[e].subarray(0,s);r.set(t[e].subarray(0,r.length)),n.set(t[e].subarray(r.length))}}else{for(let r=0;r<this.channelCount;r++)this.channelData[r].subarray(a,s).set(t[r].subarray(0,e));s===this.bufferLength&&(s=0)}return Atomics.store(this.states,this.States.WRITE,s),!0}pull(t,e){const a=Atomics.load(this.states,this.States.READ);Atomics.load(this.states,this.States.WRITE);let s=a+e;if(this.bufferLength<s){s-=this.bufferLength;for(let e=0;e<this.channelCount;e++){const r=this.channelData[e].subarray(a),n=this.channelData[e].subarray(0,s);t[e].set(r),t[e].set(n,r.length)}}else{for(let e=0;e<this.channelCount;++e)t[e].set(this.channelData[e].subarray(a,s));s===this.bufferLength&&(s=0)}return Atomics.store(this.states,this.States.READ,s),!0}getBufferLength(){return this.bufferLength-1}hasEnoughFramesFor(t){const e=Atomics.load(this.states,this.States.READ),a=Atomics.load(this.states,this.States.WRITE);return this._getAvailableRead(e,a)>=t}hasEnoughSpaceFor(t){const e=Atomics.load(this.states,this.States.READ),a=Atomics.load(this.states,this.States.WRITE);return this._getAvailableWrite(e,a)>=t}_getAvailableWrite(t,e){return e>=t?this.bufferLength-e+t-1:t-e-1}_getAvailableRead(t,e){return e>=t?e-t:e+this.bufferLength-t}_reset(){for(let t=0;t<this.channelCount;t++)this.channelData[t].fill(0);Atomics.store(this.states,this.States.READ,0),Atomics.store(this.states,this.States.WRITE,0)}printAvailableReadAndWrite(){const t=Atomics.load(this.states,this.States.READ),e=Atomics.load(this.states,this.States.WRITE);console.log(this,{availableRead:this._getAvailableRead(t,e),availableWrite:this._getAvailableWrite(t,e)})}}const e=t,a=512;let s=null,r=null,n=null,i=null,o=null,u=null,l=null,h=null,c=null,f=null,A=null,E=null,d=null,g=null,b=0,p=0,y=0,m=1;async function _(){if(!s.pull([i],a))return void console.error("[worker.js] Pulling from inputQueue failed.");const t=await async function(t){u.queue.writeBuffer(h,0,new Float32Array(t));const e=u.createCommandEncoder(),s=e.beginComputePass();s.setPipeline(A),s.setBindGroup(0,E),s.dispatchWorkgroups(Math.ceil(a/d)),s.end(),e.copyBufferToBuffer(c,0,f,0,l),u.queue.submit([e.finish()]),await f.mapAsync(GPUMapMode.READ,0,l);const r=new Float32Array(a);return r.set(new Float32Array(f.getMappedRange())),f.unmap(),r}(i);r.push([t],a)||console.error("[worker.js] Pushing to outputQueue failed.")}self.addEventListener("message",(async t=>{if("init"===t.data.type)for(({inputQueue:s,outputQueue:r,atomicState:n}=t.data.data.queueData),Object.setPrototypeOf(s,e.prototype),Object.setPrototypeOf(r,e.prototype),i=new Float32Array(a),o=t.data.data.sampleRate,d=t.data.data.workgroupSize,g=t.data.data.code,await async function(){l=a*Float32Array.BYTES_PER_ELEMENT;const t=await navigator.gpu.requestAdapter();u=await t.requestDevice(),h=u.createBuffer({size:a*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),c=u.createBuffer({size:a*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),f=u.createBuffer({size:a*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST});let e=u.createShaderModule({code:g});A=u.createComputePipeline({layout:"auto",compute:{module:e,entryPoint:"main",constants:{WORKGROUP_SIZE:d}}}),E=u.createBindGroup({layout:A.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:h}},{binding:1,resource:{buffer:c}}]})}(),m=o/a;;)if("ok"===Atomics.wait(n,0,1)){const t=performance.now(),e=t-b;b=t,y+=e,await _();const a=performance.now()-t;p-=p/m,p+=a/m,y>=1e3&&(console.log(`[worker.js] process() = ${a.toFixed(3)}ms : avg = ${p.toFixed(3)}ms : callback interval = ${e.toFixed(3)}ms`),y-=1e3),Atomics.store(n,0,0)}}))})();