"use strict";(self.webpackChunkwebgpuaudio=self.webpackChunkwebgpuaudio||[]).push([[165],{5664:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>l,default:()=>_,frontMatter:()=>d,metadata:()=>h,toc:()=>m});var i=t(5893),o=t(1151),s=t(7294),r=t(1229),a=t(1077),u=t(8281);class f{timeoutId=null;nextChunkOffset=0;workgroupSize=0;constructor(e){this.audioContext=new AudioContext,this.sampleRate=this.audioContext.sampleRate,this.chunkDurationInSeconds=e,this.chunkNumSamplesPerChannel=this.sampleRate*e,this.chunkNumSamples=2*this.chunkNumSamplesPerChannel,this.chunkBufferSize=this.chunkNumSamples*Float32Array.BYTES_PER_ELEMENT}async initGPU(e){let{code:n,entryPoint:t,workgroupSize:i}=e;this.workgroupSize=i;const o=await navigator.gpu.requestAdapter();this.device=await o.requestDevice(),this.timeInfoBuffer=this.device.createBuffer({size:Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.chunkBuffer=this.device.createBuffer({size:this.chunkBufferSize,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),this.chunkMapBuffer=this.device.createBuffer({size:this.chunkBufferSize,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),this.audioShaderModule=this.device.createShaderModule({code:n}),this.pipeline=this.device.createComputePipeline({layout:"auto",compute:{module:this.audioShaderModule,entryPoint:t,constants:{SAMPLE_RATE:this.sampleRate,WORKGROUP_SIZE:i}}}),this.bindGroup=this.device.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this.timeInfoBuffer}},{binding:1,resource:{buffer:this.chunkBuffer}}]})}playSound(){(async()=>{await this.createSoundChunk()})()}async createSoundChunk(){if(!this.audioContext)return;void 0===this.startTime&&(this.startTime=performance.now()/1e3);const e=this.startTime+this.nextChunkOffset-performance.now()/1e3;if(Math.floor(e/this.chunkDurationInSeconds)>2){const e=this.chunkDurationInSeconds;return void(this.timeoutId=setTimeout(await this.createSoundChunk.bind(this),1e3*e))}this.device.queue.writeBuffer(this.timeInfoBuffer,0,new Float32Array([this.nextChunkOffset]));const n=this.device.createCommandEncoder(),t=n.beginComputePass();t.setPipeline(this.pipeline),t.setBindGroup(0,this.bindGroup),t.dispatchWorkgroups(Math.ceil(this.chunkNumSamplesPerChannel/this.workgroupSize)),t.end(),n.copyBufferToBuffer(this.chunkBuffer,0,this.chunkMapBuffer,0,this.chunkBufferSize),this.device.queue.submit([n.finish()]),await this.chunkMapBuffer.mapAsync(GPUMapMode.READ,0,this.chunkBufferSize);const i=new Float32Array(this.chunkNumSamples);i.set(new Float32Array(this.chunkMapBuffer.getMappedRange())),this.chunkMapBuffer.unmap();const o=this.audioContext.createBuffer(2,this.chunkNumSamplesPerChannel,this.audioContext.sampleRate),s=[];for(let a=0;a<2;++a)s.push(o.getChannelData(a));for(let a=0;a<o.length;++a)for(const[e,n]of s.entries())n[a]=i[2*a+e];const r=this.audioContext.createBufferSource();r.buffer=o,r.connect(this.audioContext.destination),0!==this.nextChunkOffset&&r.start(this.nextChunkOffset),this.nextChunkOffset+=r.buffer.duration,await this.createSoundChunk()}async stop(){this.timeoutId&&clearTimeout(this.timeoutId),this.audioContext&&await this.audioContext.suspend(),this.audioContext&&await this.audioContext.close()}}const c="override WORKGROUP_SIZE: u32 = 256;\noverride SAMPLE_RATE: f32 = 44100.0;\nconst PI2: f32 = 6.283185307179586476925286766559;\n\nstruct TimeInfo { offset: f32 }\n\n@group(0) @binding(0) var<uniform> time_info: TimeInfo;\n@group(0) @binding(1) var<storage, read_write> sound_chunk: array<vec2<f32>>;\n\n@compute @workgroup_size(WORKGROUP_SIZE)\nfn synthesize(@builtin(global_invocation_id) global_id: vec3<u32>) {\n    let sampleX = global_id.x;\n\n    let t = f32(sampleX) / SAMPLE_RATE;\n\n    sound_chunk[sampleX] = sine(time_info.offset + t);\n}\n\nfn sine(time: f32) -> vec2<f32> {\n    const freq: f32 = 333;\n    var v: f32 = sin(time * freq * PI2);\n    const amp: f32 = 0.25;\n    return vec2(v * amp);\n}",d={title:"WGSL Audio Editor, no real-time inputs",sidebar_position:1},l=void 0,h={id:"wgslEditor/WgslAudioNoInput",title:"WGSL Audio Editor, no real-time inputs",description:"const [playing, setPlaying] = useState(false);",source:"@site/docs/wgslEditor/WgslAudioNoInput.mdx",sourceDirName:"wgslEditor",slug:"/wgslEditor/WgslAudioNoInput",permalink:"/docs/wgslEditor/WgslAudioNoInput",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"WGSL Audio Editor, no real-time inputs",sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Audio Shaders: wgsl web editor",permalink:"/docs/category/audio-shaders-wgsl-web-editor"},next:{title:"WGSL Audio Editor, with real-time inputs",permalink:"/docs/wgslEditor/WgslAudioEditorWithInputs"}},p={},m=[],g=function(){const e={li:"li",ul:"ul",...(0,o.a)()},n=[1,2,4,8,16,32,64,128,256],[t,d]=(0,s.useState)(!1),[l,h]=(0,s.useState)(void 0),[p,m]=s.useState(c);(0,s.useEffect)((()=>()=>{b()}),[]);const g=(0,s.useCallback)(((e,n)=>{console.log("val:",e),m(e)}),[]),{chunkDurationInSeconds:v,workgroupSize:_,loadShader:S}=(0,u.M4)({loadShader:{options:["sine","triangle","square","sawtooth","globalIdX","time"]},chunkDurationInSeconds:{value:.25,min:.03,max:1,step:.01},workgroupSize:{options:n,value:n[8]},[t?"Stop Sound":"Play Sound"]:(0,u.LI)((()=>{d(!t)}))},[t]);async function b(){l&&(await l.stop(),h(void 0))}return(0,s.useEffect)((()=>{t?async function(){if(void 0===l){const e=new f(v);await e.initGPU({code:p,entryPoint:"synthesize",workgroupSize:_}),h(e)}}():b()}),[t]),(0,s.useEffect)((()=>{t&&d(!1)}),[v,_,p]),(0,s.useEffect)((()=>{switch(console.log("shader",S),S){case"sine":default:m(c);break;case"triangle":m("override WORKGROUP_SIZE: u32 = 256;\noverride SAMPLE_RATE: f32 = 44100.0;\n\nstruct TimeInfo { offset: f32 }\n\n@group(0) @binding(0) var<uniform> time_info: TimeInfo;\n@group(0) @binding(1) var<storage, read_write> sound_chunk: array<vec2<f32>>;\n\n@compute @workgroup_size(WORKGROUP_SIZE)\nfn synthesize(@builtin(global_invocation_id) global_id: vec3<u32>) {\n    let sampleX = global_id.x;\n\n    let t = f32(sampleX) / SAMPLE_RATE;\n\n    sound_chunk[sampleX] = triangleWave(time_info.offset + t);\n}\n\nfn triangleWave(time: f32) -> vec2<f32> {\n    const freq: f32 = 333;\n    var v: f32 = -abs(fract(time * freq)-0.5)*4.0-1.0;\n    const amp: f32 = 0.25;\n    return vec2(v * amp);\n}");break;case"square":m("override WORKGROUP_SIZE: u32 = 256;\noverride SAMPLE_RATE: f32 = 44100.0;\n\nstruct TimeInfo { offset: f32 }\n\n@group(0) @binding(0) var<uniform> time_info: TimeInfo;\n@group(0) @binding(1) var<storage, read_write> sound_chunk: array<vec2<f32>>;\n\n@compute @workgroup_size(WORKGROUP_SIZE)\nfn synthesize(@builtin(global_invocation_id) global_id: vec3<u32>) {\n    let sampleX = global_id.x;\n\n    let t = f32(sampleX) / SAMPLE_RATE;\n\n    sound_chunk[sampleX] = square(time_info.offset + t);\n}\n\nfn square(time: f32) -> vec2<f32> {\n    const freq: f32 = 333;\n    var v: f32 = step(fract(time * freq), 0.5) * 2.0 - 1.0;\n    const amp: f32 = 0.25;\n    return vec2(v * amp);\n}");break;case"sawtooth":m("override WORKGROUP_SIZE: u32 = 256;\noverride SAMPLE_RATE: f32 = 44100.0;\n\nstruct TimeInfo { offset: f32 }\n\n@group(0) @binding(0) var<uniform> time_info: TimeInfo;\n@group(0) @binding(1) var<storage, read_write> sound_chunk: array<vec2<f32>>;\n\n@compute\n@workgroup_size(WORKGROUP_SIZE)\nfn synthesize(@builtin(global_invocation_id) global_id: vec3<u32>) {\n    let sampleX = global_id.x;\n\n    let t = f32(sampleX) / SAMPLE_RATE;\n\n    sound_chunk[sampleX] = sine(time_info.offset + t);\n}\n\nfn sine(time: f32) -> vec2<f32> {\n    const freq: f32 = 333;\n    var v: f32 = 1.0 - 2.0*fract(time * freq);\n    const amp: f32 = 0.25;\n    return vec2(v * amp);\n}");break;case"globalIdX":m("override WORKGROUP_SIZE: u32 = 256;\noverride SAMPLE_RATE: f32 = 44100.0;\nconst PI2: f32 = 6.283185307179586476925286766559;\n\nstruct TimeInfo { offset: f32 }\n\n@group(0) @binding(0) var<uniform> time_info: TimeInfo;\n@group(0) @binding(1) var<storage, read_write> sound_chunk: array<vec2<f32>>;\n\n@compute @workgroup_size(WORKGROUP_SIZE)\nfn synthesize(@builtin(global_invocation_id) global_id: vec3<u32>) {\n    let sampleX = global_id.x;\n\n    let t = f32(sampleX) / SAMPLE_RATE;\n\n    sound_chunk[sampleX] = sine(time_info.offset + t, f32(global_id.x));\n}\n\nfn sine(time: f32, freq: f32) -> vec2<f32> {\n    var v: f32 = sin(time * freq * PI2);\n    const amp: f32 = 0.25;\n    return vec2(v * amp);\n}");break;case"time":m("override WORKGROUP_SIZE: u32 = 256;\noverride SAMPLE_RATE: f32 = 44100.0;\nconst PI2: f32 = 6.283185307179586476925286766559;\n\nstruct TimeInfo { offset: f32 }\n\n@group(0) @binding(0) var<uniform> time_info: TimeInfo;\n@group(0) @binding(1) var<storage, read_write> sound_chunk: array<vec2<f32>>;\n\n@compute @workgroup_size(WORKGROUP_SIZE)\nfn synthesize(@builtin(global_invocation_id) global_id: vec3<u32>) {\n    let sampleX = global_id.x;\n\n    let t = f32(sampleX) / SAMPLE_RATE;\n\n    sound_chunk[sampleX] = sine(time_info.offset + t, ((t - time_info.offset) * 400) + 200);\n}\n\nfn sine(time: f32, freq: f32) -> vec2<f32> {\n    var v: f32 = sin(time * freq * PI2);\n    const amp: f32 = 0.25;\n    return vec2(v * amp);\n}")}}),[S]),(0,s.useEffect)((()=>{l&&l.playSound()}),[l]),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(e.ul,{children:[(0,i.jsx)(e.li,{children:"Audio Synthesis uses rough streaming architecture to get chunks out of WebGPU."}),(0,i.jsx)(e.li,{children:"Select different shaders in the Leva control panel to hear different sounds."}),(0,i.jsx)(e.li,{children:"When changing WebGPU Parameters, the sound will stop and will need to be restarted."}),(0,i.jsx)(e.li,{children:"Some of the sounds reveal the underlying architecture of the WebGPU shader, such a s the `globalIdX` and `time` shaders."}),(0,i.jsx)(e.li,{children:"Fully refresh the page if things get strange."}),(0,i.jsx)(e.li,{children:"The code below in the live wgsl editor creates the audio data in the WebGPU compute shader."})]}),(0,i.jsx)(u.Zf,{flat:!0,oneLineLabels:!0}),(0,i.jsx)(r.ZP,{value:p,width:"90%",height:"400px",extensions:[(0,a.i)()],onChange:g})]})};function v(e){return(0,i.jsx)(i.Fragment,{})}function _(e={}){return(0,i.jsx)(g,{...e,children:(0,i.jsx)(v,{...e})})}}}]);